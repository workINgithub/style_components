(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["group-views"],{"0068":function(t,e,r){"use strict";var a=r("4db6"),n=r.n(a);n.a},"1b75":function(t,e,r){"use strict";var a=r("ed81"),n=r.n(a);n.a},"1e4b":function(t,e,r){"use strict";r.r(e);var a=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"index-container"},[r("h1",{staticClass:"title"},[t._v("hello，xiaofan's blog")]),t._m(0),r("div",[r("p",[t._v("可能会有很多地方有问题，也希望能指出，我的邮箱是 15990127563@163.com")]),r("p",[r("a",{attrs:{target:"_blank",href:"https://github.com/workINgithub"}},[r("icon-svg",{attrs:{svgId:"icon-test1"}}),t._v("github地址")],1)])]),r("p")])},n=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 一些学习笔记，而且我觉得可以在这个项目练习一些技术点，也希望能一直坚持开发下去"),r("br"),t._v(" 此外，因为我觉得这个笔记并非解释整个知识点的过程用途等，我只会提及我觉得比较重要的点 ")])}],i={name:"slog-index"},s=i,l=(r("fa1d"),r("2877")),c=Object(l["a"])(s,a,n,!1,null,"a074ce22",null);e["default"]=c.exports},3655:function(t,e,r){},4348:function(t,e,r){t.exports=r.p+"img/createComputedGetter.8b163422.png"},"4bb5":function(t,e,r){"use strict";r.r(e);var a=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[r("main-view-title",{attrs:{mainTitle:t.mainTitle}}),r("subtitle",{attrs:{subtitle:t.subtitle1}}),t._m(0),t._m(1),r("subtitle",{attrs:{subtitle:t.subtitle2}}),t._m(2),r("subtitle",{attrs:{subtitle:t.subtitle3}}),t._m(3),r("subtitle",{attrs:{subtitle:t.subtitle4}}),t._m(4)],1)},n=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 反正刚开始想了解源码的时候，js基础很差，对一些es6的语法还不怎么掌握"),r("br"),t._v(" 所以但凡你想了解源码，先得对JS非常熟练，了解闭包，了解各种静态方法"),r("br"),t._v(" 类似Object.defineProperty(),Array的push、pop、splice等等"),r("br"),t._v(" 然后你可能想看源码了，我建议先去找一些大牛的博客，通过别人的理解先熟"),r("br"),t._v(" 悉大概一个过程。"),r("br"),t._v(" 进阶后你可以去github上下载源码，自己一行一行去解读这个过程。 ")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",[a("div",[t._v(' 先贴一张官方的依赖收集图片 "data-touch"，在你阅读完这片小文章后'),a("br"),t._v(" 希望你能对这张图有个大概对了解,另外建议配合源码食用 ")]),a("img",{attrs:{src:r("fc19"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 首先initData函数，是在initState()中调用的，它在调用是在vue周期是在"),r("br"),t._v(" beforeCreate()-created()之间 它主要干了两件事: "),r("br"),t._v(" 1.将data对象或是返回的对象中的每个属性挂载到了vue实例上"),r("br"),t._v(" 2.调用observe()函数，那么这步就是将对象中的每个属性变成了响应式的"),r("br")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 事实上，第一步还有这些过程。"),r("br"),t._v(" 1. 保存data，如果data是函数则调用赋值给data（建议后期仔细看下getData())，如果是对象则直接赋值 "),r("br"),t._v(" 2. 遍历data中对key，判断每个key都唯一（与props和methods做比较) "),r("br"),t._v(" 3. 调用proxy(),结果就是读写vue.a,就是读写vm._data.a ")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",[t._v(" 将data中的每个属性变为响应式的！！！"),a("br"),t._v(" 它的核心就是observe()函数，整一个源代码目录中，你可以看到关于observe相关的"),a("br"),t._v(" 有整整一个文件夹，就可以知道它的重要性了"),a("br"),t._v(" observe()函数主要就干了一件事生成一个observe对象，new Observer(value) 这个value=>就是data "),a("br"),a("strong",[t._v("接下来new Observer()真的很重要，建议多次阅读")]),t._v(" data后面用value称号，事实上源码也是这么命名的这个形参的"),a("br"),t._v(" 1.首先是对observer对象的构建 "),a("br"),t._v(" { "),a("br"),t._v(" value: this.value 也就是为什么你console $data时，会出现无限嵌套 "),a("br"),t._v(" dep : new Dep() 这个真的很重要，和$set有关，是手动触发视图更新的关键 "),a("br"),t._v(" vmCount : 0 "),a("br"),t._v(" } "),a("br"),t._v(" 最后就是把自身挂载到value上 def(value, '__ob__', this) "),a("br"),t._v(" value可数组可对象，主要讲下对象，数组可以自己往下读 "),a("br"),t._v(" 随后就是调用this.walk(value) "),a("br"),t._v(" 这个函数很简单，就是遍历每个key，然后调用difineReactive() "),a("br"),t._v(" 下面就是关键了，注入defineReactive的两个形参先记下一份是obj也就是value，一个是key "),a("br"),t._v(" 函数第一个语句 就是 "),a("strong",[t._v("const dep = new Dep()")]),t._v(" 你可以看下上面也有个dep，这里先不解释 "),a("br"),t._v(" 略过一些代码，往下看，就到了Object.difineProperty() "),a("br"),a("img",{attrs:{src:r("520d"),alt:""}}),a("div",[t._v(" 注意这一行代码 let childOb = !shallow && observe(val) "),a("br"),t._v(" 如果这个key对应的val是个对象，那么childOb就会指向这个val的__ob__ "),a("br"),t._v(" 先知道这点就行了，等会再来看这里 "),a("br"),t._v(" 然后就是通过Object.difineProperty()，拦截对这个属性对读写 "),a("br"),t._v(" 但其实上，但凡有个watcher对象读这个属性watcher.get，就会进入 "),a("br"),t._v(" dep.depend这个分支，而且如果这个属性的val是个对象，这个watcher "),a("br"),t._v(" 还会收入这个对象的observer的dep中，这就是为啥每个observer对象得 "),a("br"),t._v(" 有个dep，因为165行中的dep你是触碰不到的，但这个dep你是可以手动获取到的 "),a("br"),t._v(" 这也是$set()的核心 "),a("br")]),a("img",{attrs:{src:r("daa0"),alt:""}}),a("div",[t._v(" set就相对简单了，但是我们得分情况而定 "),a("br"),t._v(" 1. newVal 是基础类型，则会释放childOb "),a("br"),t._v(" 2. newVal 是引用类型，则会重新调用observe(),也就是重新建立响应数据 "),a("br")]),a("div",[a("strong",[t._v("打个总结：")]),a("br"),t._v(" 每个属性都有私有的dep "),a("br"),t._v(" 每个值为对象的属性存有一个__ob__: observe对象，这是为了手动触发视图更新的，observer中的dep是不会变的 "),a("br"),t._v(" 但每个属性的私有dep是会变的 ")])])}],i={name:"init-data",data:function(){return{mainTitle:"简单讲讲initData",subtitle1:"推荐学习过程",subtitle2:"过程",subtitle3:"第一件事",subtitle4:"第二件事"}}},s=i,l=(r("0068"),r("2877")),c=Object(l["a"])(s,a,n,!1,null,"d8488e52",null);e["default"]=c.exports},"4db6":function(t,e,r){},"503b":function(t,e,r){t.exports=r.p+"img/computed_new_watcher.f05a91ce.png"},"520d":function(t,e,r){t.exports=r.p+"img/data_get.26f526bc.png"},"55c1":function(t,e,r){"use strict";r.r(e);var a=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"container"},[t._m(0),r("main",[r("div",[t._v(t._s(t.reason))]),r("div",{staticClass:"table-container"},[r("div",{staticClass:"sub-title"},[t._v("自由的tbody：")]),r("div",[t._v(t._s(t.templateTable))]),r("style-table",{attrs:{tableHeader:t.tableHeader,tableData:t.tableData,openDIY:"true"},scopedSlots:t._u([{key:"cool",fn:function(e){return[r("td",{staticClass:"td-template td-single-ele"},[t._v(t._s(e.row.name))]),r("td",{staticClass:"td-template td-single-ele"},[t._v(t._s(e.row.birthday))]),r("td",{staticClass:"td-template"},[t._v(t._s(e.row.age))]),r("tr",[r("td",{staticClass:"td-template",staticStyle:{"text-align":"left"},attrs:{colspan:"3"}},[t._v("留言:")])])]}}])})],1)])])},n=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("header",[r("h1",{staticClass:"title"},[t._v("table")])])}],i=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[r("table",{staticClass:"default",attrs:{width:"100%"}},[r("colgroup",t._l(t.tableHeader,(function(t,e){return r("col",{key:e,attrs:{width:t.width}})})),0),r("tbody",[r("tr",t._l(t.tableHeader,(function(e,a){return r("th",{key:a},[t._v(t._s(e.title))])})),0)]),t._l(t.tableData,(function(e,a){return r("tbody",{key:a,staticClass:"table-data"},[t.Default?r("tr",{staticClass:"default-tr"},[t._t("default",null,{row:e})],2):t._e(),t.DIY?t._t("cool",null,{row:e}):t._e()],2)}))],2)])},s=[],l={name:"style-table",props:["tableHeader","tableData","openDefault","openDIY"],data:function(){return{Default:this.openDefault,DIY:this.openDIY}}},c=l,o=(r("8fee"),r("2877")),u=Object(o["a"])(c,i,s,!1,null,"88099b58",null),v=u.exports,b={name:"style-Table-index",components:{StyleTable:v},data:function(){return{reason:"目的: el-table满足不了需求，所以定制了这个table，后来觉得这个table的成长性很高，所以拿到这里来，试试看能不能逐渐演变成成熟table组件,话不多说下面是效果及原理",tableHeader:[{width:"100",title:"姓名"},{width:"100",title:"生日"},{width:"100",title:"年龄"}],tableData:[{name:"张小凡",birthday:"1998/01/16",age:"21"},{name:"乐川",birthday:"2019/09/25",age:"1"}],templateTable:"原理：table只提供了提供了表格容器，你大可通过template-slot绘制自己需要的表格具体说明下我的理解对于template-slot，这个组件自由度很高，对应关系可以通过这个例子：卡带A(template)的插槽(slot)叫小霸王，那么他可以插到叫小霸王(name)的游戏机(slot)上,然后template就可以拿到相应slot的所有属性"}}},_=b,d=(r("8afe"),Object(o["a"])(_,a,n,!1,null,"1c283eb8",null));e["default"]=d.exports},"5cde":function(t,e,r){"use strict";var a=r("e6c8"),n=r.n(a);n.a},"6fad":function(t,e,r){},"7b11":function(t,e,r){"use strict";r.r(e);var a=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"layout-container"},[r("h1",{staticClass:"title"},[t._v("关于整个网站的布局")]),r("div",[t._v(t._s(t.afterTitle))]),r("div",[t._v(t._s(t.productStructure))]),t._m(0)])},n=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("响应式布局: 通过mixins全局混入+vuex，使得在访问页面时确认终端尺寸，并触发样式更换")]),r("li",[t._v(" 非移动端: 左侧栏fixed，右侧标准盒模型，偏移左侧宽度，移动端: 右侧宽度100%，左侧自动隐藏，点击菜单栏可 显示，点击灰色图层隐藏 ")]),r("li",[t._v("SVG")])])}],i={name:"layout-component",data:function(){return{afterTitle:"因为我想在这个博客里练习一些基础的东西，所以我决定整个bolg使用的技术就是html+css+vue.js，不使用其他的组件框架等",content:"",productStructure:"网站结构"}}},s=i,l=(r("5cde"),r("2877")),c=Object(l["a"])(s,a,n,!1,null,"31b75aa0",null);e["default"]=c.exports},"8afe":function(t,e,r){"use strict";var a=r("fe39"),n=r.n(a);n.a},"8fee":function(t,e,r){"use strict";var a=r("ef19"),n=r.n(a);n.a},"929a":function(t,e,r){"use strict";var a=r("a7e2"),n=r.n(a);n.a},a7e2:function(t,e,r){},b075:function(t,e,r){t.exports=r.p+"img/computed_usage.5c0c7060.png"},b1bf:function(t,e,r){"use strict";var a=r("3655"),n=r.n(a);n.a},b878:function(t,e,r){t.exports=r.p+"img/initWatch.ca8a2e53.png"},cd01:function(t,e,r){"use strict";r.r(e);var a=function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",[a("main-view-title",{attrs:{"main-title":t.mainTitle}}),a("subtitle",{attrs:{subtitle:t.subtitle1}}),t._m(0),a("subtitle",{attrs:{subtitle:t.subtitle2}}),t._m(1),t._m(2),t._m(3),t._m(4),t._m(5),t._m(6),t._m(7),t._m(8),a("subtitle",{attrs:{subtitle:t.subtitle3}}),t._m(9),t._m(10),t._m(11),a("img",{attrs:{src:r("d955"),alt:""}}),t._m(12)],1)},n=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 这两个选项配置，都是用于监听各个属性的变化，而后执行callback "),r("br"),t._v(" computed更多用于的是计算值，watch则是监听某个属性变化后执行用户定义的cb "),r("br")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 完全的使用的语法就如同下方,但实际上最多的用法就是声明 属性名:函数(), "),r("br"),t._v(" 而且在服务端渲染中，并不支持set ")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",[a("img",{attrs:{src:r("b075"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 实际定义在initComputed函数中 主要做了以下几件事 "),r("br"),t._v(" 1. 遍历computed,获得getter函数（也就是get函数）"),r("br"),t._v(" 2. 非SSR背景下,对每个属性创建相应的watcher,并放在watchers对象里 "),r("br"),t._v(" 3. 调用defineComputed(),实际上就是在vue实例上，通过Object.defineProperty(),设置各个属性的拦截器 ")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",[t._v(" 接下来我们看看对watcher的定义 "),a("img",{attrs:{src:r("503b"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 这里先记一下,形参( vm, getter, noop, computedWatcherOptions ) "),r("br"),t._v(" computedWatcherOptions = { laze: true } "),r("br"),t._v(" 调用new Watcher() "),r("br"),t._v(" 初始化watcher的过程就不在列举了，注意几个参数 源码地址 /src/core/observe/watcher"),r("br"),t._v(" this.dirty = this.lazy = true 以及与dep相关的参数 "),r("br"),t._v(" this.value = this.laze ? undefined : this.get() => this.value=undefined "),r("br")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 我们再回到，defineComputed()函数中 "),r("br"),t._v(" 这个函数的意义就是封装下用户定义的get，set方法 "),r("br"),t._v(" 并通过Object.defineProperty() 在这个vm实例上定义这个computed值 ")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",[a("img",{attrs:{src:r("4348"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 捋一下整个过程,initComputed() 在initData()之后 "),r("br"),t._v(" 在vue的created()之前，创建了相应的key的watchers "),r("br"),t._v(" 在dom渲染时（这个具体时间可能有问题），触发get,这个过程就是依赖收集 "),r("br"),t._v(" 并调用getter获取新值,更新value "),r("br"),t._v(" 随后，但凡监听的data或computed值更新，订阅的computed watchers都会触发 "),r("br"),t._v(" update(),更新value ")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 相对来说，watch会比computed来得简单些。先贴initWatch() "),r("br"),t._v(" 他是最后调用的，在initData()和initComputed()之后 "),r("br"),t._v(" 他就主要做了一件事，生成user watcher ")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",[a("img",{attrs:{src:r("b878"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 这个函数很简单，就是遍历watch对象，拿到属性值handler "),r("br"),t._v(" 对handler进行解析，也就是如果hanler是数组，则对每个元素调用createWatcher函数 "),r("br"),t._v(" 这里简单描述下createWatcher函数 "),r("br"),t._v(" 主要作用就是封装参数，并调用vm.$watch(expOrFn, handler, options)函数 "),r("br"),t._v(" 那对应对形参就是(key键名=>expOrFn,handler函数=>cb,options对象) "),r("br"),t._v(" 那otions就是有用户定义的immediate,sync,deep等属性的对象 "),r("br"),t._v(" 在$watch中会多加一个属性user，这也就是user watcher的由来 "),r("br"),t._v(" 随后就是调用 new Watcher() ")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 后面大致就是watcher的构造函数调用过程，依赖收集,this.cb = handler等等 "),r("br"),t._v(" 除此外注意几个options的定义即可，尤其是sync，这也是与后面的nextTick相关 "),r("br"),t._v(" 不妨对各个options自己去理解下. ")])}],i={name:"computed-watch",data:function(){return{mainTitle:"computed和watch",subtitle1:"异同点",subtitle2:"computed（computed watcher）",subtitle3:"watch (user wacher)"}}},s=i,l=(r("1b75"),r("2877")),c=Object(l["a"])(s,a,n,!1,null,"12f3c1c0",null);e["default"]=c.exports},d955:function(t,e,r){t.exports=r.p+"img/$watch.840cc5e0.png"},daa0:function(t,e,r){t.exports=r.p+"img/data_set.ac15a39d.png"},e6c8:function(t,e,r){},ed81:function(t,e,r){},ef19:function(t,e,r){},f658:function(t,e,r){"use strict";r.r(e);var a=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[r("main-view-title",{attrs:{mainTitle:t.mainTitle}}),r("div",[t._v("promise十分美丽，但是毫无疑问，链式调用promise仍然不是非常美观。")]),r("div",[t._v("generator函数和后面出现的async函数无疑是解决这个问题的好办法")]),r("subtitle",{attrs:{subtitle:t.subtitle1}}),r("div",{staticClass:"script-style"},[t._v(" 这类函数声明主要和普通函数的区别在于 * 和 yield 关键词 "),r("br"),t._v(" 例如: "),r("br"),r("code-box",{attrs:{code:t.code1}}),t._v(" 然后调用这个函数并不会执行函数内的代码，而是返回一个迭代器对象（这一点可以与iterator接口挂钩）"),r("br"),t._v(" 例如: "),r("br"),r("code-box",{attrs:{code:t.code2}})],1),r("subtitle",{attrs:{subtitle:t.subtitle2}}),t._m(0),r("subtitle",{attrs:{subtitle:t.subtitle3}}),r("div",{staticClass:"script-style"},[t._v(" 关于这个，我把async函数称之为自动调用的generator函数"),r("br"),t._v(" 具体编译原理: "),r("br"),r("code-box",{attrs:{code:t.code3}})],1),r("div",[t._v("这个函数放着，我相信绝大多数人放弃治疗了，所以后面建设也得把代码高亮放进来")])],1)},n=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"script-style"},[t._v(" 稍微复习下iterator接口，这个指的是一种规格。"),r("br"),t._v(" 应用于for...of循环，以及...扩展运算符和Array.from()函数 "),r("br"),t._v(" 1.具体要求就是对象中拥有[Symbol.iterator]这个Symbol属性,调用后返回遍历器对象"),r("br"),t._v(" 2.并每次调用对象中的next方法，返回的格式是{ value: 'something' , done: boolean } "),r("br"),t._v(" 看到这里，我想你回上方一看这与generator函数的遍历器太相似了 所以你不妨，可以声明个generator函数，用来使用这些api "),r("br"),t._v(" 另外值得一提的是 generator()返回的遍历器对象，调用[Symbol.iterator]()后返回的是他本身 ")])}],i=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[r("pre",{staticClass:"code-container"},[t._v("     "),r("code",[t._v("\n "+t._s(t.code)+"\n     ")]),t._v("\n ")])])},s=[],l={name:"code-box",props:["code"]},c=l,o=(r("b1bf"),r("2877")),u=Object(o["a"])(c,i,s,!1,null,"17a764e2",null),v=u.exports,b={name:"js-generator",data:function(){return{mainTitle:"generator",subtitle1:"简单介绍",subtitle2:"与iterator接口",subtitle3:"与async函数的关联",code1:"function* name (params) { \n  let a = yield 10; \n  let b = yield 20; \n  return a \n } ",code2:"let iterator = name() \n console.log(iterator.next()) // 10 \n console.log(iterator.next(15)) // 20 \n console.log(iterator.next()) //可以自己在浏览器控制台打印下\n 然后整个 iterator.next() 返回的对象是这样的 { value: yield右边的值, done: 是否到最后一步} \n 但最关键的是，Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的",code3:"function spwan(genF) { \n   return new Promise(function (resolve,reject) { \n   let iterator = genF()  //这个是遍历器对象 \n     step()\n     function step(data) {\n       let item\n       try {\n         item = iterator.next(data)\n       } catch(error) {\n          reject(error)     //注意这里的reject是最外层的promise的参数\n       } \n       if( item.done === true) {\n          resolve(item.value) //注意这里的resolve是最外层的promise的参数\n        } <br>\n        Promise.resolve(item.value).then(function (data) {\n           step(data)\n        },function (error) {\n           reject(error)     //注意这里的reject是最外层的promise的参数\n        })\n     }\n    })\n   } \n}"}},components:{CodeBox:v}},_=b,d=(r("929a"),Object(o["a"])(_,a,n,!1,null,"29b30e7c",null));e["default"]=d.exports},f969:function(t,e,r){"use strict";r.r(e);var a=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[r("main-view-title",{attrs:{mainTitle:t.mainTitle}}),r("subtitle",{attrs:{subtitle:t.subtitle}}),r("div",[t._v(" 整个hooks的触发过程在vue-router官网中介绍的很清楚 "),r("br"),t._v(" 但是我想讲些不同的 你可以认为在调用$router.push()的过程中，实际上有两个队列按照先后顺序依次出队 "),r("subtitle",{attrs:{subtitle:t.tohone}}),t._m(0),t._v(" 你可以先理解resolveAsyncComponents这个函数，是触发队列2的导火线。然后情况比我形容的复杂的多 "),r("subtitle",{attrs:{subtitle:t.tohtow}}),t._m(1),t._v(" 或许这样,你会容易记忆的多。但事实上这样的分组和源码也是一致的。 "),r("br"),t._v(" 然后我就想提几个我之前不会使用的写法。 "),r("br"),t._v(" 1.beforeRouteLeave和beforeRouteUpdate,可以写成函数数组的形式，然而beforeRouteEnter不可以 "),r("br"),t._v(" 2.尝试使用name去匹配组件,而不是path(因为name是从字典中找寻找，而path则需要遍历，需要验证下) "),r("br"),t._v(" 3.beforeRouteEnter中实例并未渲染成功,所以在函数内不得使用this。但您可以在next回调函数中传入回调函数, do something,因为此时已渲染完毕 "),r("br"),t._v(" 4.每个hook都得调用next()，否则不会进入到下一环节。afterEach实际上就是队列的尾部，写法3.我陈述的，是源码 自动会执行的cbs数组 ")],1),r("div",[t._v(" 有些地方可能词不达意，敬请谅解。最好的方法还是自己去反复的看源码。这是我自己的一些理解 "),r("a-link",{attrs:{link:"https://github.com/workINgithub/web_study/blob/master/vue/vue-router%E8%A7%A3%E6%9E%90.md"}})],1)],1)},n=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("beforeRouteLeave(组件失活)")]),r("li",[t._v("beforeEach(在导航开始之前)")]),r("li",[t._v("beforeRouteUpdate(相同的组件更新)")]),r("li",[t._v("beforeEnter(确认导航)")]),r("li",[t._v("resolveAsyncComponents(解决,同步,组件)")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("beforeRouteEnter(进入激活的组件)")]),r("li",[t._v("beforeResolve(导航结束之前)")]),r("li",[t._v("afterEach(导航结束之后)")]),r("li",[t._v("执行 用户自己 在beforeRouterEnter函数中 传入next回调函数的参数(这个参数也是回调函数)")])])}],i={name:"vue-router",data:function(){return{mainTitle:"vue-router的一些技巧",subtitle:"hooks流程",tohone:"队列1",tohtow:"队列2"}}},s=i,l=r("2877"),c=Object(l["a"])(s,a,n,!1,null,"0d9472d6",null);e["default"]=c.exports},fa1d:function(t,e,r){"use strict";var a=r("6fad"),n=r.n(a);n.a},fc19:function(t,e,r){t.exports=r.p+"img/data.5de7af21.png"},fe39:function(t,e,r){}}]);
//# sourceMappingURL=group-views.2225a29a.js.map