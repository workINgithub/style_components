(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-40a12f16"],{"039a":function(t,e,r){"use strict";var n=r("faec"),i=r.n(n);i.a},"0632":function(t,e,r){"use strict";var n=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[r("h3",[t._v(t._s(t.subtitle))])])},i=[],c={name:"subtitle",props:["subtitle"]},a=c,s=r("2877"),u=Object(s["a"])(a,n,i,!1,null,"45a9ab29",null);e["a"]=u.exports},"100c":function(t,e,r){"use strict";var n=r("416f"),i=r.n(n);i.a},"416f":function(t,e,r){},4348:function(t,e,r){t.exports=r.p+"img/createComputedGetter.8b163422.png"},"503b":function(t,e,r){t.exports=r.p+"img/computed_new_watcher.f05a91ce.png"},b075:function(t,e,r){t.exports=r.p+"img/computed_usage.5c0c7060.png"},b878:function(t,e,r){t.exports=r.p+"img/initWatch.ca8a2e53.png"},cd01:function(t,e,r){"use strict";r.r(e);var n=function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",[n("main-title",{attrs:{"main-title":t.mainTitle}}),n("subtitle",{attrs:{subtitle:t.subtitle1}}),t._m(0),n("subtitle",{attrs:{subtitle:t.subtitle2}}),t._m(1),t._m(2),t._m(3),t._m(4),t._m(5),t._m(6),t._m(7),t._m(8),n("subtitle",{attrs:{subtitle:t.subtitle3}}),t._m(9),t._m(10),t._m(11),n("img",{attrs:{src:r("d955"),alt:""}}),t._m(12)],1)},i=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 这两个选项配置，都是用于监听各个属性的变化，而后执行callback "),r("br"),t._v(" computed更多用于的是计算值，watch则是监听某个属性变化后执行用户定义的cb "),r("br")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 完全的使用的语法就如同下方,但实际上最多的用法就是声明 属性名:函数(), "),r("br"),t._v(" 而且在服务端渲染中，并不支持set ")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",[n("img",{attrs:{src:r("b075"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 实际定义在initComputed函数中 主要做了以下几件事 "),r("br"),t._v(" 1. 遍历computed,获得getter函数（也就是get函数）"),r("br"),t._v(" 2. 非SSR背景下,对每个属性创建相应的watcher,并放在watchers对象里 "),r("br"),t._v(" 3. 调用defineComputed(),实际上就是在vue实例上，通过Object.defineProperty(),设置各个属性的拦截器 ")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",[t._v(" 接下来我们看看对watcher的定义 "),n("img",{attrs:{src:r("503b"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 这里先记一下,形参( vm, getter, noop, computedWatcherOptions ) "),r("br"),t._v(" computedWatcherOptions = { laze: true } "),r("br"),t._v(" 调用new Watcher() "),r("br"),t._v(" 初始化watcher的过程就不在列举了，注意几个参数 源码地址 /src/core/observe/watcher"),r("br"),t._v(" this.dirty = this.lazy = true 以及与dep相关的参数 "),r("br"),t._v(" this.value = this.laze ? undefined : this.get() => this.value=undefined "),r("br")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 我们再回到，defineComputed()函数中 "),r("br"),t._v(" 这个函数的意义就是封装下用户定义的get，set方法 "),r("br"),t._v(" 并通过Object.defineProperty() 在这个vm实例上定义这个computed值 ")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",[n("img",{attrs:{src:r("4348"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 捋一下整个过程,initComputed() 在initData()之后 "),r("br"),t._v(" 在vue的created()之前，创建了相应的key的watchers "),r("br"),t._v(" 在dom渲染时（这个具体时间可能有问题），触发get,这个过程就是依赖收集 "),r("br"),t._v(" 并调用getter获取新值,更新value "),r("br"),t._v(" 随后，但凡监听的data或computed值更新，订阅的computed watchers都会触发 "),r("br"),t._v(" update(),更新value ")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 相对来说，watch会比computed来得简单些。先贴initWatch() "),r("br"),t._v(" 他是最后调用的，在initData()和initComputed()之后 "),r("br"),t._v(" 他就主要做了一件事，生成user watcher ")])},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",[n("img",{attrs:{src:r("b878"),alt:""}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 这个函数很简单，就是遍历watch对象，拿到属性值handler "),r("br"),t._v(" 对handler进行解析，也就是如果hanler是数组，则对每个元素调用createWatcher函数 "),r("br"),t._v(" 这里简单描述下createWatcher函数 "),r("br"),t._v(" 主要作用就是封装参数，并调用vm.$watch(expOrFn, handler, options)函数 "),r("br"),t._v(" 那对应对形参就是(key键名=>expOrFn,handler函数=>cb,options对象) "),r("br"),t._v(" 那otions就是有用户定义的immediate,sync,deep等属性的对象 "),r("br"),t._v(" 在$watch中会多加一个属性user，这也就是user watcher的由来 "),r("br"),t._v(" 随后就是调用 new Watcher() ")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",[t._v(" 后面大致就是watcher的构造函数调用过程，依赖收集,this.cb = handler等等 "),r("br"),t._v(" 除此外注意几个options的定义即可，尤其是sync，这也是与后面的nextTick相关 "),r("br"),t._v(" 不妨对各个options自己去理解下. ")])}],c=r("ed08"),a=r("0632"),s={name:"computed-watch",components:{MainTitle:c["a"],Subtitle:a["a"]},data:function(){return{mainTitle:"computed和watch",subtitle1:"异同点",subtitle2:"computed（computed watcher）",subtitle3:"watch (user wacher)"}}},u=s,l=(r("039a"),r("2877")),_=Object(l["a"])(u,n,i,!1,null,"2344379c",null);e["default"]=_.exports},d955:function(t,e,r){t.exports=r.p+"img/$watch.840cc5e0.png"},ed08:function(t,e,r){"use strict";var n=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"main-title"},[r("h1",[t._v(t._s(t.mainTitle))])])},i=[],c={name:"main-view-title",props:["mainTitle"]},a=c,s=(r("100c"),r("2877")),u=Object(s["a"])(a,n,i,!1,null,"2b84df55",null);e["a"]=u.exports},faec:function(t,e,r){}}]);
//# sourceMappingURL=chunk-40a12f16.e004f898.js.map